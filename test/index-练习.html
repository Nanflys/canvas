<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		*{
			margin:0;
			padding:0;
		}
		body{
			background:#ccc;
			padding:40px;
		}
		#canvas{
			background:#fff;
			color:#fff;
		}
	</style>
</head>
<body>
	<canvas id="canvas" width="920" height="920">
		<span>不支持canvas的浏览器</span>
	</canvas>	<!-- 默认宽：300，高：150 -->
	<script>
		var oC = document.getElementById('canvas'); //获取元素

		var oGc = oC.getContext('2d');	//获取在画布上绘图的环境，只支持2D绘制，webgl支持3D（只在少数浏览器支持）

		oGc.save();
		oGc.beginPath();
		oGc.lineWidth = 5;
		oGc.strokeRect(5,5,795,895);
		oGc.closePath();
		oGc.restore();

		oGc.save();
		oGc.beginPath();
		for (var i = 1; i < 8; i++) {
			oGc.lineWidth = 3;
			oGc.moveTo(100*i,5);
			oGc.lineTo(100*i,900);
		}
		oGc.closePath();
		oGc.stroke();
		oGc.restore();


		oGc.save();
		oGc.beginPath();
		for (var i = 1; i < 9; i++) {
			oGc.lineWidth = 3;
			oGc.moveTo(5,100*i);
			oGc.lineTo(800,100*i);
		}
		oGc.closePath();
		oGc.stroke();
		oGc.restore();

		oGc.save();
		oGc.font = '20px 微软雅黑';
		oGc.translate(450,100);
		oGc.rotate(90*Math.PI/180);
		oGc.fillText("lalallala",0,0);
		oGc.restore();


		oGc.save();
		oGc.font = '20px 微软雅黑';
		oGc.translate(400,250)
		oGc.rotate(90*Math.PI/180);
		oGc.fillText("3333333333",200,200);
		oGc.restore();

		oGc.beginPath();
		oGc.fillStyle = '#fff';
		oGc.fillRect(8,500,789,90);
		oGc.closePath();

//--------------------------------------------------绘制方块-----------------------------------------------------------------------

			//--------------------fillRect方法------------------------------------

		// fillRect(L,T,W,H)绘制方块 括号里面分别是（left值，top值，宽。高），默认背景色是黑色
		// oGc.fillRect(50,50,200,200)

			//----------------------stroke方法----------------------------------

			// strokeRect（L,T,W,H）绘制带边框的方块默认1px边框，显示为2px出来不一样的原因，解决方案：后期有设置绘图可避免
			// oGc.strokeRect(50.5,50.5,200,200)

//--------------------------------------------------设置绘图---------------------------------------------------------------------

			//fillstyle：填充颜色（绘制canvas是有顺序的）
			// oGc.fillStyle = 'red';
			// oGc.fillRect(50,50,200,200)

			//lineWidth：线宽度，是一个数值
			// oGc.lineWidth = 10;
			// oGc.strokeRect(50.5,50.5,200,200)

			//strokeStyle：边线颜色
			// oGc.strokeStyle = 'blue';
			// oGc.strokeRect(50.5,50.5,200,200)


//---------------------------------------------------边界绘制----------------------------------------------------------------------

			//----------------------------------------linejoin边界连接点样式-------------------------------------------------------
				// oGc.lineJoin = 'bevel'; 		//miter(默认)，round（圆角），bevel（切角）
				// oGc.lineWidth = 10;
				// oGc.strokeRect(50.5,50.5,200,200);



			//---------------------------------------linecap端点样式---------------------------------------------------------

			// oGc.lineWidth = 10;
			// oGc.lineCap = 'square';		//round 圆角；square：高度多出宽度一半的值
			// oGc.moveTo(100,100);
			// oGc.lineTo(300,300);
			// oGc.stroke();



//-------------------------------------------------直线绘制-----------------------------------------------------------

				// oGc.beginPath();
				// oGc.moveTo(100,100);
				// oGc.lineTo(200,200);
				// oGc.lineTo(300,200);
				// oGc.closePath();
				// oGc.stroke();

				// oGc.beginPath();
				// oGc.moveTo(100,200);
				// oGc.lineTo(200,300);
				// oGc.lineTo(300,300);
				// oGc.closePath();
				// oGc.fill();

//------------------------下面绘制方法是一开始上面方法的分解步骤------------------------------------------

				// oGc.beginPath();
				// oGc.rect(100,100,200,200)
				// oGc.closePath();
				// oGc.stroke();


				// oGc.save();
				// oGc.beginPath();
				// oGc.rect(100,100,200,200)
				// oGc.closePath();
				// oGc.stroke();
				// oGc.clearRect(0,0,oC.width,oC.height);

				// oGc.restore();

//--------------------------------------------------鼠标画线-----------------------------------------

				// oC.onmousedown = function(e){
				// 	var e = e || window.event;

				// 	oGc.moveTo(e.clientX-oC.offsetLeft,e.clientY-oC.offsetTop);

				// 	document.onmousemove = function(e){
				// 		var e = e || window.event;

				// 		oGc.lineTo(e.clientX-oC.offsetLeft,e.clientY-oC.offsetTop);

				// 		oGc.stroke();
				// 	}

				// 	document.onmouseup = function(){
				// 		document.onmousemove = document.onmouseup = null;
				// 	}
				// };


//-------------------------------------------------方块移动------------------------------------------

				// var num = 0;
				// oGc.fillRect(0,0,100,100);

				// setInterval(function(){
				// 	num++;
				// 	oGc.clearRect(0,0,oC.width,oC.height);
				// 	oGc.fillRect(num,num,100,100);
				// },30)



				// var n = 0;

				// function sum(n){
				// 	n++;
				// 	var result = Math.sin(n*Math.PI/180);
				// 	console.log(result*10)
				// }
				// for (var i = 0; i < 360; i++) {
				// 	sum(i)
				// }





















































































































	</script>
</body>
</html>